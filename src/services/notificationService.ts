
'use server';

import type { SellerNotification } from '@/types';
import { adminDb } from '@/lib/firebaseConfig';
import { FieldValue }from 'firebase-admin/firestore';

// Define the input type for the sendMessage action
interface ContactArtisanData {
  customerName: string;
  messageText: string;
}

/**
 * A Server Action to send a message to an artisan by creating a notification.
 * @param artisanId The ID of the artisan receiving the message.
 * @param artisanName The name of the artisan for the success message.
 * @param formData The message content from the form.
 * @returns A promise that resolves to an object with success status and a message.
 */
export async function sendMessage(artisanId: string, artisanName: string, formData: ContactArtisanData) {
    try {
        const notificationPayload = {
            type: 'new_message' as const,
            title: `New Message from ${formData.customerName || 'Customer'}`,
            description: formData.messageText,
            artisanId: artisanId,
            sender: formData.customerName || 'Customer',
            link: `/dashboard/seller/messages/thread/${artisanId}/${Date.now()}` 
        };
        await createNotification(notificationPayload);
        return { success: true, message: `Your message has been sent to ${artisanName}.` };
    } catch (error) {
        console.error("Failed to send message and create notification", error);
        return { success: false, message: "Could not send your message. Please try again later." };
    }
}

// Define the input type, omitting fields that will be generated by the server.
type NotificationInput = Omit<SellerNotification, 'id' | 'timestamp' | 'read'>;

/**
 * Creates a new notification document in Firestore.
 * @param data The notification data to save.
 * @returns The ID of the newly created notification, or null on error.
 */
export async function createNotification(data: NotificationInput): Promise<string | null> {
    try {
        const newNotificationRef = adminDb.collection('notifications').doc();
        const notificationData = {
            ...data,
            read: false,
            timestamp: FieldValue.serverTimestamp(), // Use server-generated timestamp
        };
        await newNotificationRef.set(notificationData);
        return newNotificationRef.id;
    } catch (error) {
        console.error("Error creating notification:", error);
        return null;
    }
}

/**
 * Fetches all notifications for a specific artisan.
 * @param artisanId The ID of the artisan.
 * @returns A promise that resolves to an array of SellerNotification objects.
 */
export async function getNotificationsByArtisanId(artisanId: string): Promise<SellerNotification[]> {
    if (!artisanId) return [];
    try {
        const notificationsSnapshot = await adminDb.collection('notifications')
            .where('artisanId', '==', artisanId)
            .orderBy('timestamp', 'desc')
            .limit(50) // Limit to a reasonable number for performance
            .get();
        
        if (notificationsSnapshot.empty) return [];

        const notifications: SellerNotification[] = notificationsSnapshot.docs.map(doc => {
            const data = doc.data();
            return {
                id: doc.id,
                ...data,
                // Convert Firestore Timestamp to a standardized ISO string for the client
                timestamp: data.timestamp?.toDate().toISOString() || new Date().toISOString(),
            } as SellerNotification;
        });
        
        return notifications;
    } catch (error) {
        console.error(`Error fetching notifications for artisan ID ${artisanId}:`, error);
        return [];
    }
}

/**
 * Updates a specific notification document.
 * @param notificationId The ID of the notification to update.
 * @param updates The fields to update.
 * @returns A promise that resolves to true if successful, false otherwise.
 */
export async function updateNotification(notificationId: string, updates: Partial<Pick<SellerNotification, 'read'>>): Promise<boolean> {
    try {
        await adminDb.collection('notifications').doc(notificationId).update(updates);
        return true;
    } catch (error) {
        console.error(`Error updating notification ${notificationId}:`, error);
        return false;
    }
}

/**
 * Marks all unread notifications for an artisan as read using a batch write.
 * @param artisanId The ID of the artisan.
 * @returns A promise that resolves to true if successful, false otherwise.
 */
export async function markAllNotificationsAsRead(artisanId: string): Promise<boolean> {
    try {
        const notificationsSnapshot = await adminDb.collection('notifications')
            .where('artisanId', '==', artisanId)
            .where('read', '==', false)
            .get();
        
        if (notificationsSnapshot.empty) return true;

        const batch = adminDb.batch();
        notificationsSnapshot.docs.forEach(doc => {
            batch.update(doc.ref, { read: true });
        });

        await batch.commit();
        return true;
    } catch (error) {
        console.error(`Error batch updating notifications for artisan ${artisanId}:`, error);
        return false;
    }
}

/**
 * Deletes all notifications for an artisan using a batch write.
 * @param artisanId The ID of the artisan.
 * @returns A promise that resolves to true if successful, false otherwise.
 */
export async function clearAllNotificationsForArtisan(artisanId: string): Promise<boolean> {
     try {
        const notificationsSnapshot = await adminDb.collection('notifications')
            .where('artisanId', '==', artisanId)
            .get();
        
        if (notificationsSnapshot.empty) return true;

        const batch = adminDb.batch();
        notificationsSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });

        await batch.commit();
        return true;
    } catch (error) {
        console.error(`Error batch deleting notifications for artisan ${artisanId}:`, error);
        return false;
    }
}
